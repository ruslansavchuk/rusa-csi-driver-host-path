using Csi.HostPath.Node.Application.Common.Configuration;
using Csi.HostPath.Node.Application.Common.Controller;
using Csi.HostPath.Node.Application.Node.Common;
using Csi.HostPath.Node.Application.Node.Stage;
using MediatR;

namespace Csi.HostPath.Node.Application.Node.Publish;

public class EphemeralVolumeProvisioner
{
    private readonly IVolumeController _volumeController;
    private readonly INodeConfiguration _nodeConfiguration;
    private readonly IMediator _mediator;

    public EphemeralVolumeProvisioner(
        IVolumeController volumeController, 
        INodeConfiguration nodeConfiguration, 
        IMediator mediator)
    {
        _volumeController = volumeController;
        _nodeConfiguration = nodeConfiguration;
        _mediator = mediator;
    }

    public async Task<string> Stage(string volumeId, Dictionary<string, string> volumeContext, CancellationToken cancellationToken)
    {
        // as I can see, volume id for ephemeral volume generated by some part of kubernetes (i think kubelet),
        // will use it as volume name, because it is different format than I use
        var name = volumeId;

        const long defaultVolumeSize = 1024 * 1024 * 1024; // 1gi
        var capacity = volumeContext.TryGetValue("size", out var size) && SizeParser.TryParseSize(size, out var bytes) 
            ? bytes 
            : defaultVolumeSize;

        var volume = await _volumeController.Create(name, capacity, cancellationToken);
        await _volumeController.Publish(volume.Id, _nodeConfiguration.NodeId, cancellationToken);

        // create stage directory for the ephemeral volumes
        var stagePath = EphemeralVolumeHelper.GetVolumeStageDir(_nodeConfiguration.CsiDataDir, volume.Id);
        
        var stageVolumeCommand = new StageVolumeCommand(volume.Id, stagePath, volume.Context);
        await _mediator.Send(stageVolumeCommand, cancellationToken);

        return stagePath;
    }

    public async Task TryUnStage(string volumeId, CancellationToken cancellationToken)
    {
        // as I can see, volume id for ephemeral volume generated by some part of kubernetes (i think kubelet),
        // will use it as volume name, because it is different format than I use
        var name = volumeId;

        var volumes = await _volumeController.ListVolumes(cancellationToken);

        var volume = volumes.SingleOrDefault(v => v.Name == name);

        // we need to check if the volume requested is ephemeral
        if (volume is not null && EphemeralVolumeHelper.IsEphemeral(volume.Context))
        {
            // if volume is ephemeral it should be assigned to current node
            // because we know that name of the ephemeral volume is unique entirely
            // it means that we cat unstage this volume
            var stagePath = EphemeralVolumeHelper.GetVolumeStageDir(_nodeConfiguration.CsiDataDir, volume.Id);
            var stageVolumeCommand = new StageVolumeCommand(volume.Id, stagePath, volume.Context);
            await _mediator.Send(stageVolumeCommand, cancellationToken);
            
            // if volume is ephemeral, we need to unpublish it and remove from volume controller
            await _volumeController.Unpublish(volumeId, _nodeConfiguration.NodeId, cancellationToken);
            await _volumeController.Delete(volumeId, cancellationToken);
        }
    }
}